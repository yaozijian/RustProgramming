# 1 所有权

## 1.1 Copy 与 Clone

* Copy定义于std::marker模块；Clone定义于std::clone模块
* Copy继承自Clone，所以实现Copy的类型必须同时实现Clone。
* 对Copy的调用总是隐含的：如果类型实现了Copy，则在赋值、作为函数参数/返回值传递时自动采用复制语义（总是简单的比特复制）。
* 对Clone的调用总是显式的：如果类型实现了Clone，则可以调用其clone方法来克隆一个对象，克隆的语义可以由程序员控制。

## 1.2 Copy

* Copy的行为总是简单的比特复制，这个行为是无法覆盖的。
* 虽然实现Copy的类型必须同时实现Clone，但是实现Clone的方式不会影响Copy的行为。
* 内置的简单类型（整数、浮点数、布尔、字符）都实现了Copy。
* 组成类型的所有元素（字段）都实现了Copy时，类型可以实现Copy。注意是“可以实现Copy”，而不是实现了Copy。在类型可以实现Copy时，可以用两种方法之一为类型实现Copy:
  * 使用derive指令：```#[derive(Copy)]```
  * 使用```impl Copy for <类型名>```
* 注意：Copy特性不含方法，所以只需要用前述两种方法之一声明类型实现了Copy即可，不用写任何实现代码。   
* 类型实现Copy后，赋值、作为函数参数/返回值传递时，将使用复制语义，而不是移动所有权。

## 1.3 Clone

可以用两种方法之一为类型实现Clone

* 使用derive指令：```#[derive(Clone)]```，用这种方法实现Clone时，Clone.clone()方法的语义等同于Copy，即简单的比特复制。
* 使用```impl Clone for <类型名>```：用这种方法实现Clone时，必须编码实现clone方法。
  * 若类型实现了Copy，则clone方法的主体可以简单地写作```*self```，即简单地调用复制语义；当然，此时也可以编码以实现其他方式的克隆。
  * 若类型没有实现Copy，则必须编码实现特定的克隆方式。
  
## 1.4 Drop

* Drop特性定义在std::ops模块中，仅含有一个drop方法：```fn drop(&mut self)```。
* 变量超出作用域时，drop方法被自动调用；不能显式调用drop方法，这将导致编译错误；但可以对实现了Drop的类型调用std::mem::drop方法来间接地调用drop方法。
* Drop特性与Copy特性不相容，类型不能同时实现这两个特性。
* Drop调用是递归的，对某类型调用Drop的时候，会递归调用组成类型的各个元素的Drop特性。
* Drop调用次序与变量声明次序相反，即后声明的先Drop。

# 2 引用

* 引用(reference)用&表示，与之相对的是解引用(dereference)，用*表示
* 可变引用用&mut表示
* 注意：引用不同于C++中的引用，而是类似于C++中的cconst指针；而可变引用类似于C++中的指针。
* 通过引用操作变量称作借用(borrowing)
* 同一时刻一个变量可以有多个引用；却只能有一个可变引用；可变引用与引用互斥。

# 3 切片

* 切片是字符串、数组、切片的一部分的引用
  * 用大括号包围的起止下标表示
  * 起止下标间用两个小数点连接，起止下标表示的区间为左闭右开的
  * 必要时可省略两个下标之一，或者全部省略
* 字面字符串的类型是&str，即不可变的字符串切片引用
* <font color="red">不能对字符串进行索引操作，只能进行切片操作，且切片时要注意下标在正确的字符边界上</font>
* String与&str
  * 通常使用String与&str，而不使用str
  * &str转到String：```String::from()```，需要另外分配内存，开销大
  * String转到&str：```&s[..]```，不需要另外分配内存，开销小
